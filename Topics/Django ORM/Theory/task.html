<h2>Django ORM</h2>
<div class="step-text">
<p>The storage you work with is probably a file system. It works well for HTML pages and templates, but how do you keep small objects like login, age, or favorite color for each person? Relational databases can help you organize and handle such data.</p><p>Let's start from scratch and learn how to use only Python to work with databases. </p><h5 id="relational-databases">Relational databases</h5><p>If your first thought is <em>I need to keep the data with a typical structure</em>, then your second thought should surely be databases.</p><p>A <strong>relational database</strong> is a collection of multiple data sets organized by tables, records, and columns. It works fine for most types of data. Each implementation provides the universal language called Structured Query Language (SQL).</p><p>The most popular databases include PostgreSQL, Oracle SQL, MS SQL, and MySQL. There is also a simple database that works on your smartphone in many applications: SQLite. It's perfect for one-client use and trying out Django models for the first time. SQLite is included in the list of libraries for Django by default, so you probably already have it. Check whether you have it on your computer:</p><pre><code class="language-bash">sqlite3 --version</code></pre><p>If you don't, install it with your package manager or download it from the <a href="https://www.sqlite.org/download.html" rel="noopener noreferrer nofollow" target="_blank">official site</a>.</p><h5 id="object-relational-mapping">Object-relational mapping</h5><p>With summer almost over and clouds getting heavier, the new season of Quidditch is almost here. As you know, wizards lack computer science classes, even though programming is a kind of magic. They want to store the teams, their results, and the rosters on the website, and they wonder if there is a way to do it with Django. Well, there is! For this, let's create the <code class="language-bash">quidditch</code> project with the <code class="language-bash">tournament</code> app in it. Let's meet and greet <strong>Django Models</strong>!</p><p>Django Models are classes that map objects from the real world to the database records. We will work with databases using Python classes and methods. Our strong side is the programming language, and we will make the most of it. It will also make the code independent of the specific database used by our application (and defined in the <em>settings.py</em> file). The objects are similar to the database records, and their methods resemble SQL commands. There's no need to know SQL directly as we apply the instruments that imitate it. We have teams, so we call our model the <code class="language-bash">Team</code>. </p><p>To tell Django that it's a class that maps its structure to the database table, we inherit the <code class="language-bash">Team</code> from <code class="language-bash">django.models.Model</code>. Also, we have players and game tables. Suppose we have the <code class="language-bash">quidditch</code> project with the <code class="language-bash">tournament</code> application inside. Let's make the stubs for our classes in the <em>tournament/models.py</em> module:</p><pre><code class="language-python">from django.db import models


class Team(models.Model):
    name = ...


class Player(models.Model):
    height= ...
    name = ...
    team = ...


class Game(models.Model):
    date = ...
    home_team = ...
    home_team_points = ... 
    rival_team = ...
    rival_team_points = ...</code></pre><p>We gave names to our classes and described their content. The restriction of all relational databases is that we should define the types for all the fields in the model. So how can we match the types with the fields?</p><h5 id="fields">Fields</h5><p>To get most of the database's features, we use the <code class="language-bash">Fields</code> classes. They map the class attribute to a particular column in the database table. Does it mean we need the instance of a class for each field? Yes, but don't worry; it's easier than it may seem.</p><p>To build the whole schema, we start from the core element, <code class="language-bash">Team</code><em>:</em></p><pre><code class="language-python">class Team(models.Model):
    name = models.CharField(max_length=64)</code></pre><p><code class="language-bash">CharField</code> is similar to Python string but has one restriction: the length limit. <code class="language-bash">Wigtown Wanderers</code> is the longest team name in the league now, but the league is still open to new teams, so we ensure <code class="language-bash">max_length</code> with 64 symbols.</p><p>Each team has players. Let's define a model for a player:</p><pre><code class="language-python">class Player(models.Model):
    height = models.FloatField()
    name = models.CharField(max_length=64)
    team = models.ForeignKey(Team, on_delete=models.CASCADE)</code></pre><p>We already know what the <code class="language-bash">CharField</code> means, so <code class="language-bash">FloatField</code> should sound familiar to you, too. It's the same as Python's <code class="language-bash">float</code> type. What's more interesting is the <code class="language-bash">ForeignKey</code> field. It means that the player is bound to a specific <code class="language-bash">Team</code> and the <code class="language-bash">on_delete=models.CASCADE</code> restriction means that if the <code class="language-bash">team</code> is deleted from the database, it will be erased with all the players. That sounds unfair, but you should try harder to stay in the league!</p><p></p><div class="alert alert-primary"><p>There are other deleting strategies besides <code class="language-bash">CASCADE</code>: <code class="language-bash">PROTECT</code>, <code class="language-bash">RESTRICT</code>, <code class="language-bash">SET_NULL</code>, <code class="language-bash">SET_DEFAULT</code>, <code class="language-bash">SET()</code>, and <code class="language-bash">DO_NOTHING</code>. Feel free to read more about them on <a href="https://docs.djangoproject.com/en/4.1/ref/models/fields/#django.db.models.ForeignKey.on_delete" rel="noopener noreferrer nofollow" target="_blank">the corresponding documentation page</a>.</p></div><p></p><p>Finally, there's the <code class="language-bash">Game</code> model:</p><pre><code class="language-python">class Game(models.Model):
    home_team = models.ForeignKey(Team, related_name='game_at_home', on_delete=models.CASCADE)
    home_team_points = models.IntegerField()
    rival_team = models.ForeignKey(Team, related_name='rival_game', on_delete=models.CASCADE)
    rival_team_points = models.IntegerField()
    date = models.DateField()</code></pre><p>There are no games without teams, so again, we set <code class="language-bash">on_delete=models.CASCADE</code> for each <code class="language-bash">ForeignKey</code>. Also, we add the <code class="language-bash">related_name</code> for the <code class="language-bash">Game</code> model, by which we can access it from the <em>Team</em> model, in other words, follow the relationship backward. If <code class="language-bash">related_name</code> wasn't defined, the special <code class="language-bash">game_set</code> field will show you the games in which a team participated; more can be found in <a href="https://docs.djangoproject.com/en/4.1/topics/db/queries/#backwards-related-objects" rel="noopener noreferrer nofollow" target="_blank">Django's documentation.</a></p><p>Points is an <code class="language-bash">int</code> type, so we make it <code class="language-bash">IntegerField</code>, and the date is a <code class="language-bash">DateField</code>.</p><p>You can think of <code class="language-bash">Fields</code> as expansions of Python's primitive types for simple cases like <code class="language-bash">IntegerField</code>, <code class="language-bash">CharField</code>, and <code class="language-bash">FloatField</code>. They also have special cases like <code class="language-bash">ForeignKey</code> and other <a href="https://docs.djangoproject.com/en/4.1/topics/db/models/#relationships" rel="noopener noreferrer nofollow" target="_blank">relations between objects</a>.</p><h5 id="migrations">Migrations</h5><p>We've described the mappings between Python classes and database tables, but we don't have any tables. Let's correct this. Add <code class="language-bash">tournament</code> to <code class="language-bash">INSTALLED_APPS</code> in the <em>quidditch/settings.py </em>module:</p><pre><code class="language-python">INSTALLED_APPS = [
    # other installed apps
    'tournament',
]</code></pre><p>We have the league layout in our code; we are ready to migrate it to the database. It takes two steps:</p><pre><code class="language-bash">python manage.py makemigrations
python manage.py migrate</code></pre><p>The first command creates <strong>migrations</strong>. A migration is a piece of code that describes what actions should be done in the database to synchronize the models with the tables. You can find the created code in the <em>tournament/migrations/0001_initial.py </em>file. So, don't forget to check whether the <em>migrations</em> directory exists; otherwise, migration will not be completed.</p><p>In the second step, we apply the changes and run the generated commands. Preceding <code class="language-bash">manage.py &lt;command&gt;</code> with <code class="language-bash">python</code> is the platform-independent way to launch any Django command. It's a valid syntax for both Unix and Windows systems.</p><p>In PyCharm IDE, you can open the terminal tab and add the commands. If you want to make and then apply migrations to a particular application in your project, add the application name after each command:</p><pre><code class="language-bash">python manage.py makemigrations tournament
python manage.py migrate tournament</code></pre><p>When you run these commands, your database will finally have the tables to work with.</p><p>It's important to note that when you run the <code class="language-bash">makemigrations</code> command in Django, it generates a set of migration files based on the changes you have made to your models. However, it's crucial to ensure the accuracy of your migrations before applying them to the database.</p><p>To mitigate any risks, you can use the <code class="language-bash">--dry-run</code> option as an optional argument with the makemigrations command. This allows you to perform a dry run of the migration process without actually creating or modifying any tables in the database. Instead, it prints the potential migration SQL commands that would be executed. By reviewing these commands, you can verify the correctness of your migrations before applying them to the database.</p><p>To perform a dry run of migrations, you can use the following command:</p><pre><code class="language-bash">python manage.py makemigrations --dry-run</code></pre><p>The <code class="language-bash">--dry-run</code> option allows you to preview the changes without applying them to the database. This can help test migrations and verify that the changes run as expected.</p><h5 id="conclusion">Conclusion</h5><p>Now you are familiar with models<em> </em>and ORM. There are many types of fields in Django. You can read about the different fields in the <a href="https://docs.djangoproject.com/en/4.1/ref/models/fields/" rel="noopener noreferrer nofollow" target="_blank">documentation</a>. Try and create your models!</p>
</div>
