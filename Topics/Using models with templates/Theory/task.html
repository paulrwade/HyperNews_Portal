<h2>Using models with templates</h2>
<div class="step-text">
<p>The advantage of a framework is that all its parts can interact with each other easily. Do you remember that Django is based on the Model-View-Template architecture? It consists of the model, which defines the data structure, the view, which handles the logic and interaction with the user, and the template, which controls the presentation and rendering of the data. In addition, we have forms to collect information from users. Let's see it in action — process and pass data from the database to our HTML templates and get it from HTML forms to save to the database. </p><h5 id="initial-setup">Initial setup</h5><p>Let's create our music service. This service lets you listen to various tracks, search for specific songs, and mark your favorite ones.</p><p>First, let's create our project using the following command:</p><pre><code class="language-bash">django-admin startproject music_player</code></pre><p>Now we'll create an application inside the project directory. Let's call it <code class="language-bash">play</code>.</p><pre><code class="language-bash">python manage.py startapp play</code></pre><p>We've created a new application and need to add it to the <code class="language-bash">INSTALLED_APPS</code> list in the <em>settings.py </em>file.</p><pre><code class="language-python">INSTALLED_APPS = [
    ...	
    'play',
]</code></pre><p>We don't need much for the prototype — let's use Django's <code class="language-bash">User</code> model and define another one ourselves in the <em>models.py</em> file:</p><pre><code class="language-python">from django.contrib.auth.models import User
from django.db import models


class Song(models.Model):
    title = models.CharField(max_length=128)
    artist = models.CharField(max_length=128)
    path_to_file = models.FileField(upload_to='static/')
    favorite_by = models.ManyToManyField(User, related_name='favorite_songs')</code></pre><p>All attributes of models are accessed through the dot. For example, if we create the <code class="language-bash">song</code> variable as an instance of the <code class="language-bash">Song</code> class, its attributes will be available using expressions like <code class="language-bash">song.title</code>, <code class="language-bash">song.artist</code>, etc.</p><p>The <code class="language-bash">path_to_file</code> is a relative path to a file from the <code class="language-bash">upload_to</code> directory. Don't redefine the default value for static files in the <em>settings.py</em> module, and use the <em>static</em> as a file source prefix. If we create an instance of the <code class="language-bash">Song</code> model where the value of the <code class="language-bash">path_to_file</code> field is <code class="language-bash">text.txt</code>, Django will look for the <em>text.txt</em> file in the <code class="language-bash">static</code> directory.</p><p></p><div class="alert alert-primary"><p>To make the static file directory work, create it in the root of your project and then define <a href="https://docs.djangoproject.com/en/4.2/ref/settings/#std:setting-STATICFILES_DIRS" rel="noopener noreferrer nofollow" target="_blank">STATICFILES_DIRS</a> in the <em>settings.py</em> module.</p></div><p></p><p>The next step is to place the music files in the static directory of our app.</p><p>Don't forget to migrate a newly created model:</p><pre><code class="language-bash">python manage.py makemigrations
python manage.py migrate</code></pre><p>The next step is creating a template directory inside the application — <em>play/templates/play</em>. We'll need two pages for our educational purposes: <em>song_list.html</em> and <em>play_page.html</em>.</p><p>The idea is to turn it into dynamic content generated or customized based on user requests or inputs, using server-side technologies to fetch data from a database or perform calculations before delivering the content to the user. To achieve this, we can pass a <strong>context dictionary</strong> to the template to fill it with data from our models.</p><p>A context is a dictionary with variable names as the key and their values as the value. Assume that you defined the context variable <code class="language-bash">song</code>, assigned it the value of an instance of the <code class="language-bash">Song</code> class, and want to add it to your context dictionary. Here is how to do that:</p><pre><code class="language-python">my_favorite_song = Song(title='All you need is a computer, and a little belief in yourself',
                        artist='Peachcake', 
                        path_to_file='file_aync_peachcake_2005.mp3')

context = {'song': my_favorite_song}</code></pre><p>In this case, our context dictionary is <code class="language-bash">{'song': my_favorite_song}</code>. In models, all fields will be available for the template layout; you can even access foreign keys and their fields. You can pass context dictionaries to your views to make them available for your templates.</p><p>Fill the database with your favorite music tracks through the Django admin panel: create the superuser and access the panel at <em>http://127.0.0.1:8000/admin/</em>. To make our service work, let's create two significant components: views and URL paths. Since the primary purpose of our topic is to learn to use models with templates, we will only take a quick look at these steps.</p><h5 id="views">Views</h5><p>In Django, web pages and other content (like JSON, spreadsheets, or PDFs) are delivered by <strong>views</strong>. Each view generally serves a specific function and has a particular template of HTML. For example, in our playback application, we'll need at least two view classes, one for the song list and one for the pages with a music player where we can listen to our songs.</p><p>Let's add a list of songs to the <em>views.py</em> file:</p><pre><code class="language-python">from django.views import generic
from .models import Song

class IndexView(generic.ListView):
    template_name = 'play/song_list.html'
    context_object_name = 'songs'

    def get_queryset(self):
        return Song.objects.all()</code></pre><p>As you can see, we're forming a <code class="language-bash">QuerySet</code> of song instances from the database to pass them to the template.</p><p>The second page is a detailed view of the exact music track (<em>play/play_page.html</em>). The <code class="language-bash">view</code> class for it may be like this:</p><pre><code class="language-python">class MusicFileView(generic.DetailView):
    template_name = 'play/play_page.html'
    model = Song</code></pre><p>Great job! To make things work, we need to tune the URL paths. Let's get to it!</p><h5 id="urls">URLs</h5><p>Django will choose a view by examining the URL requested by the user. We'll open the <em>urls.py</em> file of the <code class="language-bash">music_player</code> project and use the <code class="language-bash">include</code> function for the application <code class="language-bash">play</code>:</p><pre><code class="language-python">from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('play.urls')),
]</code></pre><p>Create the <em>urls.py</em> file in the application's directory and add the following code there:</p><pre><code class="language-python">from django.urls import path
from . import views

app_name = 'play'

urlpatterns = [
    path('', views.IndexView.as_view(), name='index'),
    path('&lt;int:pk&gt;/', views.MusicFileView.as_view(), name='music_file'),
]</code></pre><p>As you can see, we'll create a URL path for a music file using its primary key.</p><h5 id="forms">Forms</h5><p>One of the best features of music services is the possibility to create playlists with favorite songs. Our service needs this feature! Write the template of the <em>play_page.html</em> page with a <strong>form</strong> to use it further in <code class="language-bash">POST</code> requests:</p><pre><code class="language-html">{% if user.is_authenticated %}
&lt;h2&gt;{{song.artist }} - {{ song.title  }}&lt;/h2&gt; 
&lt;audio controls&gt;
   &lt;source src="{{ song.path_to_file }}" type="audio/mpeg"&gt;
&lt;/audio&gt;
&lt;form action="{% url 'play:likes' song.id %}" method="post"&gt;
   {% csrf_token %}
   &lt;input type="hidden" name="song_id" value="{{ song.id }}"&gt;
   &lt;button type="submit"&gt;Add to favorites&lt;/button&gt;
&lt;/form&gt;
{% endif %}</code></pre><p>We access the <code class="language-bash">id</code> field of a variable with the dot. If you looked closely at the code, you've noticed we're also using the cryptic tag <code class="language-bash">{% csrf_token %}</code>. <strong>CSRF</strong> is an abbreviation for Cross-Site Request Forgery. We don't want any fraud action to happen, so in forms, we must always use this tag to secure our applications. The CSRF token is a generated sequence of symbols that the server uses to identify a user's session. If the sequence matches, the form is considered reliable. Furthermore, we added the <code class="language-bash">user_is_authenticated</code> option to see who liked an exact song and to create lists of favorites for authenticated users of our future service.</p><p>Now we have a form to send to the server. It will process the request and add the song of our choice to our favorites.</p><p style="text-align: center;"><picture><source media="(max-width: 480px)" srcset="https://ucarecdn.com/0a20208c-d511-4999-a969-f6a1ef2eae14/-/stretch/off/-/resize/480x/-/format/webp/ 1x,https://ucarecdn.com/0a20208c-d511-4999-a969-f6a1ef2eae14/-/stretch/off/-/resize/960x/-/format/webp/ 2x,https://ucarecdn.com/0a20208c-d511-4999-a969-f6a1ef2eae14/-/stretch/off/-/resize/1440x/-/format/webp/ 3x" type="image/webp"/><source media="(max-width: 800px)" srcset="https://ucarecdn.com/0a20208c-d511-4999-a969-f6a1ef2eae14/-/stretch/off/-/resize/800x/-/format/webp/ 1x,https://ucarecdn.com/0a20208c-d511-4999-a969-f6a1ef2eae14/-/stretch/off/-/resize/1600x/-/format/webp/ 2x,https://ucarecdn.com/0a20208c-d511-4999-a969-f6a1ef2eae14/-/stretch/off/-/resize/2400x/-/format/webp/ 3x" type="image/webp"/><source srcset="https://ucarecdn.com/0a20208c-d511-4999-a969-f6a1ef2eae14/-/stretch/off/-/resize/1100x/-/format/webp/ 1x,https://ucarecdn.com/0a20208c-d511-4999-a969-f6a1ef2eae14/-/stretch/off/-/resize/2200x/-/format/webp/ 2x,https://ucarecdn.com/0a20208c-d511-4999-a969-f6a1ef2eae14/-/stretch/off/-/resize/3000x/-/format/webp/ 3x" type="image/webp"/><img alt="Object and form passed to template" height="205" src="https://ucarecdn.com/0a20208c-d511-4999-a969-f6a1ef2eae14/" width="754"/></picture></p><p></p><div class="alert alert-primary"><p>For the request to work successfully, there must be a <code class="language-bash">POST</code> request handler for the <em>/add_to_favorites </em>address in the application. You can find this URL in the form's action attribute.</p><p></p><p>When submitting a form with an <em>Add to favorites</em> button, the data will be sent to the address specified in the form's action attribute, which should match our application's <code class="language-bash">/add_to_favorites</code> address. You need to ensure that your application has a <code class="language-bash">POST</code> request handler defined for this address to handle adding a song to your favorites.</p></div><p></p><h5 id="many-objects">Many objects</h5><p>A whole playlist will be shown on the main page, <em>song_list.html</em>, and it's slightly different from having just one object per page. Using a <code class="language-bash">for</code> loop and a <code class="language-bash">QuerySet</code> would work well for a situation like that.</p><p>Let's update the content of our <em>song_list.html</em> file, dynamically replacing the content in the body with our list of songs. Moreover, modify the <code class="language-bash">get_queryset</code> method to get ten or fewer random songs from the database. Now, our context data is <code class="language-bash">{'songs': Song.objects.all()[:10]}</code>.</p><pre><code class="language-html">{% for song in songs %}
&lt;div&gt;
   &lt;h4&gt;{{ song.artist }} - {{ song.title }}&lt;/h4&gt;
&lt;/div&gt;
{% endfor %}</code></pre><p>Here's another excellent idea: add links to the music player from the playlist! So, let's change the previous code to open music file pages directly from here:</p><pre><code class="language-html">{% for song in songs %}
&lt;ul&gt;
   &lt;li&gt;&lt;a href="{% url 'play:music_file' song.id %}"&gt;{{ song.artist }} - {{ song.title }}&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
{% endfor %}</code></pre><p>Great! But why stop here? Let's add another great feature to our server and display the number of users who added it to their favorites for each song display. To complete this, access the user's <code class="language-bash">QuerySet</code> with <code class="language-bash">favorite_by</code> attribute defined in the model and call the <code class="language-bash">count</code> method on it. As for other Python objects, the only template candidates are methods with no parameters. <code class="language-bash">Count</code> is one of them.</p><pre><code class="language-html">{% for song in songs %}
&lt;ul&gt;
   &lt;li&gt;&lt;a href="{% url 'play:music_file' song.id %}"&gt;{{ song.artist }} - {{ song.title }}&lt;/a&gt;&lt;/li&gt;
   &lt;div&gt;{{ song.favorite_by.count }}&lt;/div&gt;
&lt;/ul&gt;
{% endfor %}</code></pre><p>Now the users can see which songs are popping and rocking!</p><p style="text-align: center;"><picture><source media="(max-width: 480px)" srcset="https://ucarecdn.com/4c256de0-24aa-4bdb-805f-c403abccfaff/-/stretch/off/-/resize/480x/-/format/webp/ 1x,https://ucarecdn.com/4c256de0-24aa-4bdb-805f-c403abccfaff/-/stretch/off/-/resize/960x/-/format/webp/ 2x,https://ucarecdn.com/4c256de0-24aa-4bdb-805f-c403abccfaff/-/stretch/off/-/resize/1440x/-/format/webp/ 3x" type="image/webp"/><source media="(max-width: 800px)" srcset="https://ucarecdn.com/4c256de0-24aa-4bdb-805f-c403abccfaff/-/stretch/off/-/resize/800x/-/format/webp/ 1x,https://ucarecdn.com/4c256de0-24aa-4bdb-805f-c403abccfaff/-/stretch/off/-/resize/1600x/-/format/webp/ 2x,https://ucarecdn.com/4c256de0-24aa-4bdb-805f-c403abccfaff/-/stretch/off/-/resize/2400x/-/format/webp/ 3x" type="image/webp"/><source srcset="https://ucarecdn.com/4c256de0-24aa-4bdb-805f-c403abccfaff/-/stretch/off/-/resize/1100x/-/format/webp/ 1x,https://ucarecdn.com/4c256de0-24aa-4bdb-805f-c403abccfaff/-/stretch/off/-/resize/2200x/-/format/webp/ 2x,https://ucarecdn.com/4c256de0-24aa-4bdb-805f-c403abccfaff/-/stretch/off/-/resize/3000x/-/format/webp/ 3x" type="image/webp"/><img alt="Many objects passed to template" height="225" src="https://ucarecdn.com/4c256de0-24aa-4bdb-805f-c403abccfaff/" width="734"/></picture></p><p></p><div class="alert alert-primary"><p>It's usually better to calculate such data at the stage of processing the request in a handler to define only the representation of a page in our template, but now we can break from this rule for a better understanding of the principles of interaction between models and templates</p></div><p></p><p> Fine! What else do we need to make the form of adding to favorites work? Of course, we need to add a view function to <em>views.py</em>!</p><pre><code class="language-python">from django.http import HttpResponseRedirect
from django.shortcuts import get_object_or_404
from django.urls import reverse


def likes(request, id):
    song = get_object_or_404(Song, id=request.POST.get('song_id'))
    if song.favorite_by.filter(id=request.user.id).exists():
        song.favorite_by.remove(request.user)
    else:
        song.favorite_by.add(request.user)
    return HttpResponseRedirect(reverse('play:index'))</code></pre><p>As you can see, we don't need to use a unique page for likes; redirect it to the same page.</p><p>And we need the URL path for this action; add it to patterns in <em>play/urls.py:</em></p><pre><code class="language-python">urlpatterns = [
    path('', views.IndexView.as_view(), name='index'),
    path('&lt;int:pk&gt;/', views.MusicFileView.as_view(), name='music_file'),
    path('&lt;int:id&gt;/likes/', views.likes, name='likes'),
]</code></pre><h5 id="filters">Filters</h5><p>In Django, filters are available for manipulating values within templates. While they can save time, they may also produce unexpected outcomes. It's important to note that the template processor relies on an object's string representation, which has advantages and disadvantages. To fully utilize Django, it's crucial to exercise caution when using filters.</p><p>Let's slightly change the template from the previous example:</p><pre><code class="language-html">{% for song in songs %}
&lt;ul&gt;
   &lt;li&gt;&lt;a href="{% url 'play:music_file' song.id %}"&gt;{{ song.artist }} - {{ song.title }}&lt;/a&gt;&lt;/li&gt;
   &lt;div&gt;Loved by {{ song.favorite_by.all|random }}&lt;/div&gt;
&lt;/ul&gt;
{% endfor %}</code></pre><p>We render a random <code class="language-bash">User</code> who added a song to favorites (provided we have the user's consent). Upon receiving the <code class="language-bash">QuerySet</code>, we pass it to the <code class="language-bash">random</code> filter to get one username to show.</p><p>Though this feature is quite experimental, it still has a chance to win the hearts of our users, so let's render five of them instead of just one:</p><pre><code class="language-html">{% for song in songs %}
&lt;ul&gt;
   &lt;li&gt;&lt;a href="{% url 'play:music_file' song.id %}"&gt;{{ song.artist }} - {{ song.title }}&lt;/a&gt;&lt;/li&gt;
   &lt;div&gt;Loved by {{ song.favorite_by.all|slice:5 }}&lt;/div&gt;
&lt;/ul&gt;
{% endfor %}</code></pre><p>We sliced the <code class="language-bash">QuerySet</code> and limited its length to five items: what could go wrong? Yet, when we open the browser, we get the strange output:</p><p style="text-align: center;"><picture><source media="(max-width: 480px)" srcset="https://ucarecdn.com/6cc95ab7-73a8-4383-9b39-97ee0f0242ba/-/stretch/off/-/resize/480x/-/format/webp/ 1x,https://ucarecdn.com/6cc95ab7-73a8-4383-9b39-97ee0f0242ba/-/stretch/off/-/resize/960x/-/format/webp/ 2x,https://ucarecdn.com/6cc95ab7-73a8-4383-9b39-97ee0f0242ba/-/stretch/off/-/resize/1440x/-/format/webp/ 3x" type="image/webp"/><source media="(max-width: 800px)" srcset="https://ucarecdn.com/6cc95ab7-73a8-4383-9b39-97ee0f0242ba/-/stretch/off/-/resize/800x/-/format/webp/ 1x,https://ucarecdn.com/6cc95ab7-73a8-4383-9b39-97ee0f0242ba/-/stretch/off/-/resize/1600x/-/format/webp/ 2x,https://ucarecdn.com/6cc95ab7-73a8-4383-9b39-97ee0f0242ba/-/stretch/off/-/resize/2400x/-/format/webp/ 3x" type="image/webp"/><source srcset="https://ucarecdn.com/6cc95ab7-73a8-4383-9b39-97ee0f0242ba/-/stretch/off/-/resize/1100x/-/format/webp/ 1x,https://ucarecdn.com/6cc95ab7-73a8-4383-9b39-97ee0f0242ba/-/stretch/off/-/resize/2200x/-/format/webp/ 2x,https://ucarecdn.com/6cc95ab7-73a8-4383-9b39-97ee0f0242ba/-/stretch/off/-/resize/3000x/-/format/webp/ 3x" type="image/webp"/><img alt="Wrong passing of QuerySet" height="124" src="https://ucarecdn.com/6cc95ab7-73a8-4383-9b39-97ee0f0242ba/" width="1299"/></picture></p><p>What kind of English is that? It seems like Django converted the <code class="language-bash">QuerySet</code> to a string and rendered it to HTML. It's not a result to be particularly proud of. Don't lose heart, though, as we have another trick up our sleeve:</p><pre><code class="language-html">{% for song in songs %}
&lt;ul&gt;
   &lt;li&gt;&lt;a href="{% url 'play:music_file' song.id %}"&gt;{{ song.artist }} - {{ song.title }}&lt;/a&gt;&lt;/li&gt;
   &lt;div&gt;Loved by {{ song.favorite_by.all|slice:5|unordered_list }}&lt;/div&gt;
&lt;/ul&gt;
{% endfor %}</code></pre><p>This time, we prudently convert all values to the <a href="https://docs.djangoproject.com/en/4.2/ref/templates/builtins/#unordered-list" rel="noopener noreferrer nofollow" target="_blank">unordered HTML list</a> with the <code class="language-bash">unordered_list</code> filter, and our output now looks quite satisfying:</p><p style="text-align: center;"><picture><source media="(max-width: 480px)" srcset="https://ucarecdn.com/0a6fca82-9784-4702-b6a2-e3e18da98754/-/stretch/off/-/resize/480x/-/format/webp/ 1x,https://ucarecdn.com/0a6fca82-9784-4702-b6a2-e3e18da98754/-/stretch/off/-/resize/960x/-/format/webp/ 2x,https://ucarecdn.com/0a6fca82-9784-4702-b6a2-e3e18da98754/-/stretch/off/-/resize/1440x/-/format/webp/ 3x" type="image/webp"/><source media="(max-width: 800px)" srcset="https://ucarecdn.com/0a6fca82-9784-4702-b6a2-e3e18da98754/-/stretch/off/-/resize/800x/-/format/webp/ 1x,https://ucarecdn.com/0a6fca82-9784-4702-b6a2-e3e18da98754/-/stretch/off/-/resize/1600x/-/format/webp/ 2x,https://ucarecdn.com/0a6fca82-9784-4702-b6a2-e3e18da98754/-/stretch/off/-/resize/2400x/-/format/webp/ 3x" type="image/webp"/><source srcset="https://ucarecdn.com/0a6fca82-9784-4702-b6a2-e3e18da98754/-/stretch/off/-/resize/1100x/-/format/webp/ 1x,https://ucarecdn.com/0a6fca82-9784-4702-b6a2-e3e18da98754/-/stretch/off/-/resize/2200x/-/format/webp/ 2x,https://ucarecdn.com/0a6fca82-9784-4702-b6a2-e3e18da98754/-/stretch/off/-/resize/3000x/-/format/webp/ 3x" type="image/webp"/><img alt="Correct passing of QuerySet" height="220" src="https://ucarecdn.com/0a6fca82-9784-4702-b6a2-e3e18da98754/" width="515"/></picture></p><p>Well, there are plenty of ideas to expand our service with more options, but let's stop for now and continue practicing Django in the tasks for this topic!</p><h5 id="conclusion">Conclusion</h5><p>While working with our music player, we've got in touch with the principles of Django models' use in HTML templates.</p><p>Let's summarize what we've learned:</p><ul><li><p>The way we can pass objects from the database to the template;</p></li><li><p>How to access the model's attributes for different purposes;</p></li><li><p>How to represent organized lists of objects, how to sort them and use filters;</p></li><li><p>Finally, we've seen some examples of forms, view functions, and URL patterns we can create to represent data from the database.</p></li></ul>
</div>
