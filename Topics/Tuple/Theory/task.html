<h2>Tuple</h2>
<div class="step-text">
<p>By now, you definitely know how to handle a <a class="theory-lookup" href="/learn/step/36290" rel="noopener noreferrer nofollow" target="_blank" title="In Python, a list is an ordered collection of elements, where each element can be of any data type. | Lists offer a range of operations that allow you to manipulate and work with the elements stored within them. For instance, you can insert elements, check if an element exists, and search for specific elements. Understanding these operations will enable you to effectively work with lists and harness their flexibility for various programming tasks. Lists are ordered, meaning each element has a fixed position in a list. They are iterable, meaning you can get their elements one by one. Lists can store duplicate values and different types of elements. Additionally, lists can contain other lists, and there are no restrictions or fixed list types. You can add any data you want to your list.">list</a>, the most popular <a class="theory-lookup" href="/learn/step/10014" rel="noopener noreferrer nofollow" target="_blank" title="In Python, a collection is a data structure that holds multiple items together. | The collections module in Python provides various types of collections such as OrderedDict, namedtuple, and ChainMap, which are similar to built-in data types but offer advanced features. OrderedDict is a dictionary-like object that remembers the order of the given keys, and starting from Python 3.7, built-in dictionaries also preserve the order. However, OrderedDict still has some useful features that make it a better choice in certain situations, especially in reordering operations. Namedtuple is a tuple subclass that provides a convenient way to define small, lightweight objects with named fields. ChainMap is a dictionary-like object that stores a sequence of dictionaries and provides a way to access the keys and values in them as if they were a single dictionary.">collection</a> in Python. Now let's discover an equally useful data type — <strong><a class="theory-lookup" href="/learn/step/9439" rel="noopener noreferrer nofollow" target="_blank" title="In Python, a tuple is a type of data structure that is similar to a list, but unlike lists, tuples are immutable, meaning they cannot be changed once created. | Tuples can contain zero or more elements, and elements are ordered and can contain duplicates. Tuples are defined using parentheses `()` with elements separated by commas. Tuples support several operations such as addition, multiplication, finding the first index of an element, counting the occurrences of an element, and slicing. Tuples are iterable, and you can iterate and enumerate through them. Tuples can also be used as dictionary keys since they are immutable. Tuples are faster and more memory-efficient than lists because they are immutable. However, you cannot change the value of a tuple after it is created, which can be an advantage or a disadvantage depending on the use case.">tuples</a></strong>. You should remember that they are almost identical to lists. What <a class="theory-lookup" href="/learn/step/8991" rel="noopener noreferrer nofollow" target="_blank" title="In Python, a set is a collection of unique, hashable objects that are unordered and mutable. | Sets allow you to perform mathematical set operations, such as union, intersection, and difference. You can create sets using curly braces or the set() function, and add elements using the add() or update() methods. Sets can help you avoid repetition and are useful when you need to run membership tests quickly. An empty set can be created using the set() function without any arguments. Sets are different from lists because the order of elements does not matter, and they do not allow duplicate elements.">sets</a> them apart is their <strong><a class="theory-lookup" href="/learn/step/9268" rel="noopener noreferrer nofollow" target="_blank" title="In Python, immutability refers to the property of an object that cannot be modified once it is created. | Examples of immutable objects include strings, tuples, and numbers. With immutable objects, if you try to modify them, a new object is created instead. This is in contrast to mutable objects, which can be modified in place. Immutability is useful in situations where you want to ensure that the value of an object remains constant and cannot be accidentally or intentionally modified. For instance, immutable objects are often used as keys in dictionaries or as elements in sets, since their values cannot change once they are added. Additionally, immutability can improve the performance and safety of code by preventing unintended modifications. One distinctive feature of tuples is that they do not support item assignment, meaning that you cannot change the value of an individual element in a tuple. This is because tuples are immutable, and any attempt to modify them will result in a new object being created. This can be a limitation compared to lists, which are mutable and allow for item assignment.">immutability</a></strong>.</p>
<h5 id="define-a-tuple">Define a tuple</h5>
<p>Since tuples cannot be changed, tuple creation is similar to opening a box of a fixed size, then putting several values into this box and sealing it. Once the box has been sealed, you cannot modify its size or content.</p>
<p>Use a pair of <strong>parentheses </strong>to define a tuple:</p>
<pre><code class="language-python">empty_tuple = ()
print(type(empty_tuple))  # &lt;class 'tuple'&gt;</code></pre>
<p>Empty tuples are easy to create. Then what went wrong in the following example?</p>
<pre><code class="language-python">not_a_tuple = ('cat')
print(not_a_tuple)        # 'cat'
print(type(not_a_tuple))  # &lt;class 'str'&gt;</code></pre>
<p>As you can see, the <a class="theory-lookup" href="/learn/step/5859" rel="noopener noreferrer nofollow" target="_blank" title="In Python, a variable is a named location used to store a value, which reserves a space in memory to hold that value. | When a value is stored, it can be retrieved later in the program by referencing the variable name, which serves as a reference to the memory location where the value is stored. It's important to note that multiple variables can refer to the same memory location, allowing for the creation of aliases. Variables can be defined as global or local, depending on their scope. A variable's scope refers to the part of the program where the variable can be reached by its name. A global variable is declared with the global keyword and can be accessed and modified from within a function. By default, variables created inside a function are local and cannot be accessed from outside the function. Understanding the concept of scope is important because it defines the visibility of a name within the code block. When you define a variable, it becomes either global or local. If a variable is defined at the top-level of the module, it is considered global and can be referred to from every code block in your program.">variable</a> we created stores a string. It's actually a <strong>comma </strong>that makes a tuple, not parentheses. Let's fix this piece of code:</p>
<pre><code class="language-python">now_a_tuple = ('cat',)
print(now_a_tuple)        # ('cat',)
print(type(now_a_tuple))  # &lt;class 'tuple'&gt;</code></pre>
<p>So, always use a comma when defining a <a class="theory-lookup" href="/learn/step/8077" rel="noopener noreferrer nofollow" target="_blank" title="In Python, a singleton is a design pattern that restricts the instantiation of a class to a single instance. | This is useful when you want to ensure that a class has only one object, providing a global access point to this object. In the context provided, it's mentioned that default values for optional arguments in a function, such as `None`, are singletons. This means that they always refer to the same object throughout the program. Additionally, the `True` and `False` booleans are also singletons, ensuring that there is only one instance of each in Python.">singleton</a> tuple. In fact, even if your tuple contains more than one element, separating items with commas will be enough:</p>
<pre><code class="language-python">weekend = 'Saturday', 'Sunday'
print(weekend)        # ('Saturday', 'Sunday')
print(type(weekend))  # &lt;class 'tuple'&gt;</code></pre>
<p>The built-in function <code class="language-python">tuple()</code> turns strings, lists and other <strong><a class="theory-lookup" href="/learn/step/8479" rel="noopener noreferrer nofollow" target="_blank" title="In Python, an iterable is a data type that can be iterated over, meaning it can be looped through to access its individual elements one at a time. | Iterables include data structures such as lists, tuples, dictionaries, and sets. They can be used with for loops and other functions that require an iterable object, such as the built-in function `zip()`. An iterator, on the other hand, is an object that can be iterated over and returns one element at a time. It is created from an iterable using the built-in function `iter()` and can be manually advanced using the `next()` function. In the provided context, it is mentioned that iterators represent a stream of data and implement the `__next__()` method, which returns the next item of an iterable one by one. An iterator can be created from an iterable by passing it to the built-in function `iter()`. When an iterator is passed to the `next()` function, it returns the next element of the iterable. However, once all elements of an iterable have been returned, attempting to call `next()` on the iterator will raise a `StopIteration` exception. It is also mentioned that when using a for loop, Python automatically creates an iterator from a given iterable and retrieves its elements one by one. The `zip()` function can be used to take multiple iterables and combine them into a single iterator of tuples, where each tuple contains one element from each iterable.">iterables</a> </strong>into a tuple. With this function, you can create an empty tuple as well.</p>
<pre><code class="language-python"># another empty tuple
empty_tuple = tuple()
print(empty_tuple)        # ()
print(type(empty_tuple))  # &lt;class 'tuple'&gt;

# a list turned into a tuple
bakers_dozen = tuple([12, 1])
print(bakers_dozen == (12, 1))  # True

# a tuple from a string
sound = tuple('meow')
print(sound)  # ('m', 'e', 'o', 'w')</code></pre>
<h5 id="what-can-we-do-with-tuples">What can we do with tuples?</h5>
<p>First, let's examine what characteristics lists and tuples have in common.</p>
<p>Both lists and tuples are <strong><a class="theory-lookup" href="/learn/step/10059" rel="noopener noreferrer nofollow" target="_blank" title="In Python, an ordered data structure refers to a collection that maintains the original order of its elements. | This is in contrast to unordered data structures, such as sets, where the order of elements is not preserved. In the context of the provided text, the term ordered is used in the description of the behavior of the `sort()` method and the `sorted()` function. Both of these operations allow you to sort the elements of a list in a specific order, either in ascending or descending order, based on the natural order of the stored elements or a custom key function. Furthermore, the text also mentions that dictionaries in Python 3.7 and higher are ordered collections, meaning that the order of the elements (key-value pairs) is preserved when iterating over the dictionary.">ordered</a></strong>, that is, when passing elements to these containers, you can expect that their order will remain the same. Tuples are also indifferent to the nature of data stored in them, so you can <strong>duplicate values</strong> or <strong>mix different <a class="theory-lookup" href="/learn/step/5852" rel="noopener noreferrer nofollow" target="_blank" title="In Python, a data type is a classification of data that determines how it is stored in memory, what operations can be performed on it, and how those operations are executed. | It is similar to a biological species or any other abstract attribute shared among specific objects. For example, all dogs you've seen have the type dog, but each is an individual object. When it comes to Python, data types include basic data types such as strings, numerical types, and printing types. When you assign a value to a variable, Python creates a new object, places the value inside the object, and then creates a reference from the variable name to the object.">data types</a></strong>:</p>
<pre><code class="language-python">tiny_tuple = (0, 1, 0, 'panda', 'sloth')

print(len(tiny_tuple))  # 5
print(tiny_tuple)       # (0, 1, 0, 'panda', 'sloth')</code></pre>
<p>Just like lists, tuples support <strong><a class="theory-lookup" href="/learn/step/16458" rel="noopener noreferrer nofollow" target="_blank" title="In Python, indexing is the process of accessing individual elements of a sequence, such as a list, tuple, or string, by their position. | This is done using an index, which is an integer value that represents the position of the element in the sequence. Indexing starts at 0 for the first element, and increases by 1 for each subsequent element. Negative indexing is also supported, where -1 refers to the last element, -2 refers to the second last element, and so on. It is important to note that the index of the last element is one less than the length of the sequence.">indexing</a></strong>. Be careful with indexes though, if you want to get along without <code class="language-python">IndexErrors</code>.</p>
<pre><code class="language-python">empty_tuple = ()
print(empty_tuple[0])  # IndexError

numbers = (0, 1, 2)
print(numbers[0])   # 0
print(numbers[1])   # 1
print(numbers[2])   # 2
print(numbers[3])   # IndexError</code></pre>
<p>And here the first distinctive feature of tuples comes into play. What they don't support is <strong>item assignment</strong>. While you can change an element in a list referring to this element by its index, it's not the case for tuples:</p>
<pre><code class="language-python"># ex-capitals
capitals = ['Philadelphia', 'Rio de Janeiro', 'Saint Petersburg']

capitals[0] = 'Washington, D.C.'
capitals[1] = 'Brasília'
capitals[2] = 'Moscow'
print(capitals)  # ['Washington, D.C.', 'Brasília', 'Moscow']

former_capitals = tuple(capitals)
former_capitals[0] = 'Washington, D.C.'  # TypeError</code></pre>
<p>In the example above, we tried to <a class="theory-lookup" href="/learn/step/6230" rel="noopener noreferrer nofollow" target="_blank" title="In Python, an update refers to the action of adding or modifying existing key-value pairs in a dictionary. | This can be done using the `update()` method, which allows you to add new elements to a dictionary from another dictionary or an iterable of key-value pairs. If the specified key already exists in the dictionary, the method will update the key with the new value. This is particularly useful when working with dynamic data or when you want to merge two dictionaries together.">update</a> the tuple and it didn't end well. You can't add an item to a tuple or <a class="theory-lookup" href="/learn/step/36298" rel="noopener noreferrer nofollow" target="_blank" title="In Python, the term remove is used in the context of removing elements from a collection such as a list or a dictionary. | For a list, the `remove()` method is used to remove the first occurrence of an item based on its value. If the item is not in the list, it will raise a `ValueError`. Alternatively, you can remove an item from a list by its index using the `del` keyword. For a dictionary, the `pop()` method is used to remove a key-value pair and return the associated value. The `clear()` method can be used to remove all items from a dictionary.">remove</a> it from there (unless you <a class="theory-lookup" href="/learn/step/8681" rel="noopener noreferrer nofollow" target="_blank" title="In Python, a delete refers to the action of removing or eliminating data. | In the context of working with databases using Python, delete is a statement used to remove rows of data from a table. It's important to note that delete operations are permanent and cannot be undone. Before executing a delete statement, it's a best practice to carefully consider the implications of removing the data.">delete</a> the entire tuple). However, immutability has a positive side. We'll discuss it in the next section.</p>
<h5 id="immutability-and-its-advantages">Immutability and its advantages</h5>
<p>By this time, one question might have come to your mind: why use tuples when we have lists? Predictably, all answers conduce to immutability. Let's dwell on its upsides:</p>
<ul>
<li>Tuples are <strong>faster </strong>and <strong>more memory-efficient</strong> than lists. Whenever you need to work with large amounts of data, you should give it a thought. If you are not going to modify your data, perhaps you should decide on tuples.</li>
<li>A tuple can be used as a <strong>dictionary key</strong>, whereas lists as keys will result in <code class="language-python">TypeError</code>.</li>
<li>Last but not least, it's <strong>impossible to change</strong> by accident the data stored in a tuple. It may prove a safe and robust solution to some tasks.</li>
</ul>
<h5 id="summary">Summary</h5>
<p>Those were the very basics of tuples in Python. Just like lists, tuples are <strong>ordered </strong>and <strong>iterable</strong>. Unlike lists, they are <strong>immutable</strong>. You'll learn more of tuple features in the next topics, now it's time to write your first programs with them!</p>
</div>
