<div class="step-text">
<p>There is not much sense in having a database if you don't know how to get data from it. Let's find out how it works in Django!</p><p> </p><p>Let's talk about the <strong>Model object manager</strong>. We will use it to get and filter the data for a particular model. Once you learn the syntax rules, you'll be able to easily make queries to your database. It gives you the flexibility to retrieve any objects you want.</p><p> </p><p>Reading the data is the most common operation for a web application. The clients get data from the server more often than modify or delete it.</p><p> </p><h5 id="model-object-manager">Model object manager</h5><p> </p><p>An instance of the <code class="language-python">Model</code> class represents a single row in the table of your database. To start working with a set of rows, call the Model object manager methods.</p><p> </p><p>The manager is a special class to get object(s) from a database to modify them. Django model manager<strong> </strong>is the interface through which database query operations are provided to Django models. <code class="language-python">Objects</code><strong> </strong>is the default model manager, and each model needs to have at least one model manager. To access the Manager of your model, get the attribute <code class="language-python">objects</code> of the <code class="language-python">Model</code> class.</p><p> </p><p>Currently, we work on the tournament application for the Quidditch league. The season is coming, but the website is not ready! Wizards from Hogwarts get used to working with the books and papers, so they know nothing on databases. Fortunately, you don't need magic to start querying and searching. We create models <code class="language-python">Team</code> and <code class="language-python">Player</code> and that's how we define them:</p><pre><code class="language-python">from django.db import models


class Team(models.Model):
    name = models.CharField(max_length=64)


class Player(models.Model):
    height = models.FloatField()
    name = models.CharField(max_length=64)
    team = models.ForeignKey(Team, on_delete=models.CASCADE)


team_model_manager = Team.objects
player_model_manager = Player.objects</code></pre><p></p><p>Don't worry if you don't yet understand how <code class="language-python">ForeignKey</code> or other relationship fields work. You'll learn more about them in the subsequent topics, and for now you can just follow the examples.</p><p> </p><p>It's not necessary to give an alias name to the Manager, you can use its methods simply like this: <code class="language-python">Team.objects.filter(name="Ballycastle Bats")</code>. You can choose what you like more, but for clarity, we will access it directly in all the examples.</p><p> </p><p>This small snippet helps you fill the tables with the data:</p><pre><code class="language-python">falmouth_falcons = Team.objects.create(name="Falmouth Falcons")
montrose_magpies = Team.objects.create(name="Montrose Magpies")

Player.objects.create(name="Karl Broadmoor", height=180, team=falmouth_falcons)
Player.objects.create(name="Kevin Broadmoor", height=183, team=falmouth_falcons)
Player.objects.create(name="Alasdair Maddock", height=175, team=montrose_magpies)
Player.objects.create(name="Lennox Campbell", height=197, team=montrose_magpies)</code></pre><p></p><p>You can also use <code class="language-python">bulk_create</code> method to add a list of objects into the database:</p><pre><code class="language-python"> Player.objects.bulk_create([
    Player(name="Karl Broadmoor", height=180, team=falmouth_falcons),
    Player(name="Kevin Broadmoor", height=183, team=falmouth_falcons),
    Player(name="Alasdair Maddock", height=175, team=montrose_magpies),
    Player(name="Lennox Campbell", height=197, team=montrose_magpies)
])</code></pre><p></p><p>You can use the code above in any file of your app, but don't forget to import model classes from <a href="https://models.py" rel="noopener noreferrer nofollow" target="_blank"><em>models.py</em></a> and remember that you should migrate your models before using them.</p><p> </p><h5 id="getting-an-object">Getting an object</h5><p> </p><p>One step at a time, we will start from getting the team we want and then move on to getting a distinct player.</p><p> </p><p>We will carefully pick the parameters for our first query. Our <code class="language-python">Team</code> model has two fields: <code class="language-python">id</code> and <code class="language-python">name</code>. The <code class="language-python">id</code> field is generated automatically for every model, though we do not specify it explicitly.</p><p> </p><p>We are certain that we have a team named <code class="language-python">Falmouth Falcons</code>. Let's try to get it with the manager:</p><pre><code class="language-python"> falcons = Team.objects.get(name="Falmouth Falcons")</code></pre><p></p><p>Looks fine. But what happens if we get a team that doesn't exist?</p><pre><code class="language-python"> tornados = Team.objects.get(name="Tutshill Tornados")</code></pre><p></p><p>This call raises the <code class="language-python">Team.DoesNotExist</code> exception. Unlike Python's <code class="language-python">dict</code> <code class="language-python">get</code> method, the manager's <code class="language-python">get</code> method may raise an <code class="language-python">Exception</code>. To prevent this situation and keep our program from crashing, you can wrap this call in a <code class="language-python">try-except</code> construction:</p><pre><code class="language-python">try:
    tornados = Team.objects.get(name="Tutshill Tornados")
except Team.DoesNotExist:
    ...</code></pre><p></p><p>Let's try to get the <code class="language-python">Karl Broadmoor</code> player profile from the database:</p><pre><code class="language-python"> karl_broadmoor = Player.objects.get(name="Karl Broadmoor")</code></pre><p></p><p>Karl plays for Falmouth Falcons, so we get his profile with no errors. Suppose you want to make a query that returns multiple objects:</p><pre><code class="language-python">falcons = Team.objects.get(name="Falmouth Falcons")
falcon_player = Player.objects.get(team=falcons)</code></pre><p></p><p>You will get not a player but a <code class="language-python">Player.MultipleObjectsReturned</code> exception.</p><p> </p><p>So, to prevent exceptions, you should keep in mind two rules:</p><p> </p><ul><li><p>You can only pass the parameters with the names of the fields of your model or with valid field lookups;</p></li><li><p>You should be sure that with this query you will get exactly one object.</p></li></ul><p> </p><p>It appears that life is not that easy with the <code class="language-python">get</code> queries. Occasionally, we get an object, sometimes we get an error, and we're never sure what happens next. Data may change, and our valid call will start raising an <code class="language-python">Exception</code>. You may turn to other manager methods and see what they can do for you.</p><p> </p><h5 id="filtering-objects">Filtering objects</h5><p> </p><p>Like the standard Python <code class="language-python">filter</code> function, the manager's <code class="language-python">filter</code> method returns only the objects that match the query. You don't have to know initially how many objects it will return, so it's safer than the <em>get</em> method.</p><p> </p><p>The only rule is similar to the first rule for the <code class="language-python">get</code> method:</p><p> </p><ul><li><p>You can only pass parameters with names of the fields of your model or with valid field lookups.</p></li></ul><p> </p><p>Now, we will make our queries without fear of <code class="language-python">DoesNotExist</code> and <code class="language-python">MultipleObjectReturned</code> situations. We can modify our call:</p><pre><code class="language-python"> tornados = Team.objects.filter(name="Tutshill Tornados")</code></pre><p></p><p>Although we do not have <code class="language-python">Tornados</code> in the database, no exception is raised. So, what is the difference between these two methods? The answer is the return type. The <code class="language-python">get</code> method always returns an instance of a particular model, while the <code class="language-python">filter</code> method returns a <code class="language-python">QuerySet</code>,<strong> </strong>a wrapper for a set of objects of a given model in the database.</p><p> </p><p>Filtering objects only by their exact value is not always convenient: you may want to get objects that satisfy a trickier condition. For example, it could be games where the home team scored more than 12 points. We'll start with this query:</p><pre><code class="language-python"> great_score_at_home_games = Game.objects.filter(home_team_points__gt=12)</code></pre><p></p><p>The special syntax for the parameter is: the field name, double underscores, the field lookup, a special name for actions on the field value you want to make when filtering data.</p><p> </p><p>To retrieve an object from the <code class="language-python">QuerySet</code> you can iterate it over or get the item by the index as you get it from the Python's <code class="language-python">list</code>.</p><pre><code class="language-python">tornados = Team.objects.filter(name="Tutshill Tornados")
if len(tornados) == 1:
    tornados_team = tornados[0]</code></pre><p></p><p>It's important to note that this method is good if your database contains few elements. If it's big, this may lead to memory overflow, so we recommend the <code class="language-python">count()</code> method to count the number of elements:</p><pre><code class="language-python"> Team.objects.filter(name="Tutshill Tornados").count()</code></pre><p></p><p>In addition, we want to get a <code class="language-python">Falmouth Falcons</code> player. Let's do it with the combination of the <code class="language-python">filter</code> and <code class="language-python">first</code> methods:</p><pre><code class="language-python">falcons = Team.objects.get(name="Falmouth Falcons")
falcon_player = Player.objects.filter(team=falcons).first()</code></pre><p></p><p>The last pitfall you should consider is that the <code class="language-python">first</code> method does not raise any exceptions: if no objects are found, it returns <code class="language-python">None</code>. So, before accessing any properties of an object, make sure that it's not <code class="language-python">None</code>.</p><p> </p><h5 id="using-get_or_create">Using get_or_create</h5><p> </p><p>While working with databases, you'll often encounter situations where you want to get a specific object if it exists, or create it if it doesn't. Django provides a handy method for this - <code class="language-python">get_or_create</code>.</p><p> </p><p>This method tries to fetch an object from your database based on the parameters you provide. If the object exists, it returns a tuple containing the object and a boolean value <code class="language-python">False</code>. If the object does not exist, this method creates it with the provided parameters and returns a tuple containing the new object and <code class="language-python">True</code>.</p><p> </p><p>Let's take an example. Suppose we want to get a team with the name "Puddlemere United". If it exists, we want to get it, otherwise, we want to create it. Here's how we can do it:</p><p> </p><p><code class="language-python">team, created = Team.objects.get_or_create(name="Puddlemere United")</code></p><p> </p><p>In this case, if a team named "Puddlemere United" exists in the database, <code class="language-python">team</code> will be that Team instance and <code class="language-python">created</code> will be <code class="language-python">False</code>. If the team does not exist, a new team will be created, <code class="language-python">team</code> will be the new Team instance, and <code class="language-python">created</code> will be <code class="language-python">True</code>.</p><p> </p><p>There's another way to achieve the same result, although it involves more steps. First, you check if the object exists using the <code class="language-python">.exists()</code> method, and if it doesn't, you create it. Here's how you can do it:</p><pre><code class="language-python">if not Team.objects.filter(name="Puddlemere United").exists():
    team = Team.objects.create(name="Puddlemere United")
    created = True
else:
    team = Team.objects.get(name="Puddlemere United")
    created = False</code></pre><p></p><p>In this case, if a team named "Puddlemere United" exists in the database, <code class="language-python">team</code> will be that Team instance and <code class="language-python">created</code> will be <code class="language-python">False</code>. If the team does not exist, a new team will be created, <code class="language-python">team</code> will be the new Team instance, and <code class="language-python">created</code> will be <code class="language-python">True</code>.</p><p> </p><p>While both methods achieve the same result, <code class="language-python">get_or_create</code> is more efficient because it performs the operation in a single database query, while the second method may require two queries (one to check if the object exists, and another to create it if it doesn't). Therefore, it's generally recommended to use <code class="language-python">get_or_create</code> when you want to get an object if it exists, or create it if it doesn't.</p><p> </p><h5 id="conclusion">Conclusion</h5><p> </p><p>Getting data from a database is an operation you will constantly refer to. We started polishing our skills by getting and filtering data. We found out how to retrieve a single object and a <code class="language-python">QuerySet</code> to work with them as we work with other Python classes. However, the main purpose of Django is to provide the tools to make web services, and you can easily apply your query skills for doing analytics and reports.</p><p> </p>
</div>